name: Automated Slack message

on:
  release:
    types: [published]
  repository_dispatch:
    types: [trigger-artifact-workflow]

jobs:
  store_artifacts:
    name: Store artifacts
    runs-on: ubuntu-latest
    if: github.event_name == 'repository_dispatch' && github.event.action == 'trigger-artifact-workflow'
    steps:
      - name: Access data from GitLab payload
        run: |
          echo '${{ toJSON(github.event) }}'
          echo '${{ toJSON(github.event.client_payload) }}' > artifact.json
          cat artifact.json
      - name: Upload JSON as artifact
        uses: actions/upload-artifact@v4
        with:
          name: gitlab-data-artifact
          path: artifact.json
  slack_message:
    name: Slack message
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'published'
    steps:
      - name: Download release artifact
        uses: actions/download-artifact@v4
        with:
          name: gitlab-data-artifact
          github-token: ${{ secrets.GH_PAT }}
      - name: Display artifact content
        run: cat artifact.json
      - name: Slack Markdown Converter
        id: convert
        uses: LoveToKnow/slackify-markdown-action@v1.1.1
        with:
          text: ${{ github.event.release.body }}
      - name: Prepare and send Slack message
        env:
          EVENT_CONTEXT: ${{ toJSON(github.event) }}
          CONVERTED_TEXT: ${{ steps.convert.outputs.text }}
        run: |
          node <<EOF
          (async () => {
            const payload = {
              channel: "${{ vars.SLACK_CHANNEL_ID }}",
              blocks: [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*[NEW]* My Project - ${{ github.event.release.tag_name }}",
                  },
                  "accessory": {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "Show release :rocket:",
                      "emoji": true
                    },
                    "url": "${{ github.event.release.html_url }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":clipboard: tickets JIRA :"
                  }
                },
                {
                  "type": "rich_text",
                  "elements": [
                    {
                      "type": "rich_text_list",
                      "style": "bullet",
                      "elements": []
                    }
                  ]
                }
              ]
            };

            console.log("payload", payload);

            

            try {
              const gitlabResponse = await fetch("https://${{ vars.GITLAB_DOMAIN }}/api/v4/projects/${{ vars.GITLAB_PROJECT_ID }}/merge_requests?state=merged&target_branch=develop&milestone=${{ github.event.release.tag_name }}", {
                method: "GET",
                headers: {
                  "Private-Token": "${{ secrets.GITLAB_API_TOKEN }}"
                }
              });

              if (!gitlabResponse.ok) {
                  const err = await gitlabResponse.json();
                  throw new Error("Failed to send message: " + JSON.stringify(err));
              }

              const mergeRequests = await gitlabResponse.json();
              const tickets = [];

              mergeRequests.forEach((mr) => {
                const matches = mr.source_branch.match(/EC-\d+/);
                if(matches.length) {
                  tickets.push(matches[0].toUpperCase());
                }
              });

              console.log("tickets", tickets);

              tickets.forEach((ticket) => {
                payload.blocks[2].elements[0].elements.push({
                  "type": "rich_text_section",
                  "elements": [
                    {
                      "type": "link",
                      "url": "https://${{ vars.JIRA_DOMAIN }}/browse/" + ticket,
                      "text": ticket
                    }
                  ]
                });
              });

              const slackResponse = await fetch("https://slack.com/api/chat.postMessage", {
                method: "POST",
                headers: {
                  "Authorization": "Bearer ${{ secrets.SLACK_API_TOKEN }}",
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(payload)
              });

              if (!slackResponse.ok) {
                  const err = await slackResponse.json();
                  throw new Error("Failed to send message: " + JSON.stringify(err));
              }

              console.log("Message sent successfully !");
            } catch (error) {
              console.error("Request error", error.message);
            }
          })();
          EOF
